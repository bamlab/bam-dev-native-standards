{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Getting Started"},{"location":"about/","text":"We're Hiring ! \u00b6 We are mobile developers, based in Paris, working with hybrid and cross platform technologies. Our goal is to help the client's business succeed, by solving their problems together using agile and lean, and developing the best product to satisfy the client's user needs. Learn more about us in our french website .","title":"We're Hiring !"},{"location":"about/#were-hiring","text":"We are mobile developers, based in Paris, working with hybrid and cross platform technologies. Our goal is to help the client's business succeed, by solving their problems together using agile and lean, and developing the best product to satisfy the client's user needs. Learn more about us in our french website .","title":"We're Hiring !"},{"location":"open_source/","text":"Open Source \u00b6 kstate A KMM Library to declare finite state machine (FSM) following the SCXML spec. The project has a lib for declaring Android Navigation FSM. Open the project alpha-movie An Android library to display WebM movies with a transparent background. The project is a fork. Open the project","title":"Open Source"},{"location":"open_source/#open-source","text":"kstate A KMM Library to declare finite state machine (FSM) following the SCXML spec. The project has a lib for declaring Android Navigation FSM. Open the project alpha-movie An Android library to display WebM movies with a transparent background. The project is a fork. Open the project","title":"Open Source"},{"location":"architecture/lib/","text":"Lib \u00b6 @startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(star, \"*\", \"Android Module\") System_Boundary(c2, \"Lib\") { Component(extension, \"Extension\", \"\", \"Declares dependency injection container for the current lib.\") Component(module, \"Module\", \"Class\", \"Declares the module entry points.\") Component(command, \"Command\", \"Class\", \"Declares a command.\") Component(query, \"Query\", \"Class\", \"Declares a query.\") Component(domain, \"Domain\", \"Data class\", \"Declares a domain object.\") Component(api, \"Api\", \"Interface and concrete implementation\", \"Declares a remote API.\") Component(storage, \"Storage\", \"Interface and concrete implementation\", \"Declares a local storage.\") } Rel(app, extension, \"Loads\") Rel(star, module, \"Uses\") Rel(module, command, \"Uses\") Rel(module, query, \"Uses\") Rel(query, api, \"Uses\") Rel(command, api, \"Uses\") Rel(query, storage, \"Uses\") Rel(command, storage, \"Uses\") @enduml","title":"Lib"},{"location":"architecture/lib/#lib","text":"@startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(star, \"*\", \"Android Module\") System_Boundary(c2, \"Lib\") { Component(extension, \"Extension\", \"\", \"Declares dependency injection container for the current lib.\") Component(module, \"Module\", \"Class\", \"Declares the module entry points.\") Component(command, \"Command\", \"Class\", \"Declares a command.\") Component(query, \"Query\", \"Class\", \"Declares a query.\") Component(domain, \"Domain\", \"Data class\", \"Declares a domain object.\") Component(api, \"Api\", \"Interface and concrete implementation\", \"Declares a remote API.\") Component(storage, \"Storage\", \"Interface and concrete implementation\", \"Declares a local storage.\") } Rel(app, extension, \"Loads\") Rel(star, module, \"Uses\") Rel(module, command, \"Uses\") Rel(module, query, \"Uses\") Rel(query, api, \"Uses\") Rel(command, api, \"Uses\") Rel(query, storage, \"Uses\") Rel(command, storage, \"Uses\") @enduml","title":"Lib"},{"location":"blog/","text":"Blog \u00b6 Create an animated Instagram-like progress bar with Jetpack Compose How to create a reusable Jetpack Compose component that displays Instagram's stories progress bar. Read Detect Instagram-like gestures with Jetpack Compose How to detect Instagram's stories gesture. Read","title":"Blog"},{"location":"blog/#blog","text":"Create an animated Instagram-like progress bar with Jetpack Compose How to create a reusable Jetpack Compose component that displays Instagram's stories progress bar. Read Detect Instagram-like gestures with Jetpack Compose How to detect Instagram's stories gesture. Read","title":"Blog"},{"location":"blog/create-an-animated-instagram-like-progress-bar-with-jetpack-compose/","text":"Create an animated Instagram-like progress bar with Jetpack Compose \u00b6 Jetpack Compose is the new and trending way to build Android UI. At BAM , we use it on all new projects. On older projects, we make a plan to refactor good old XML to Composable. This is the first post of a series of How to do this with Jetpack Compose. Note Posts in this series : Create an animated Instagram-like progress bar with Jetpack Compose Detect Instagram-like gestures with Jetpack Compose Info Resources : Link to Github Repo Link to Figma project Let's go ! Recreating Instagram's stories progress bar \u00b6 Do you know instagram stories ? They are a slideshow of full screen mobile pictures. Here is an example : We will try to recode the progress bar like this : Specs are : we are given a number of steps (number); we are given the current step index (number); we are given whether to pause the progression or not (boolean); we would like to be able to do something when we reach the end of a step (a callback); The layout of one progress bar \u00b6 We will use a Row with a background for the progress bar background. And a Box for the progress bar foreground. @Preview ( widthDp = 200 ) @Composable fun ProgressBarPreview () { Row ( modifier = Modifier . height ( 4. dp ) . clip ( RoundedCornerShape ( 50 , 50 , 50 , 50 )) // (1) . background ( Color . White . copy ( alpha = 0.4f )) // (2) ) { Box ( modifier = Modifier . background ( Color . White ) . fillMaxHeight () . fillMaxWidth ( 0.5f ), // (3) ) {} } } Creates rounded corner. Order of Modifier is important. Here, clip is applied on top of background . Adds the white translucent background. Fill a percentage of the width. Result : The layout of multiple progress bar \u00b6 We need to iterate over an index. @Preview ( widthDp = 600 ) @Composable fun InstagramSlicedProgressBar ( steps : Int = 3 , currentStep : Int = 2 ) { Row ( verticalAlignment = Alignment . CenterVertically , modifier = Modifier . height ( 48. dp ) . padding ( 24. dp , 0. dp ), ) { for ( index in 1. . steps ) { // (1) // We use our previous code : Row ( ... ) { Box ( modifier = Modifier ... . fillMaxHeight (). let { // Here we check if we need to fill the progress bar of not : when ( index ) { // (2) currentStep -> it . fillMaxWidth (. 5f ) in 0. . currentStep -> it . fillMaxWidth ( 1f ) else -> it } }, ) {} } if ( index != steps ) { Spacer ( modifier = Modifier . width ( 4. dp )) // (3) } } } } We iterate over a range from 1 to the given steps number. Before current step, we fill the progress bar; at the current step, we fill a fraction; after, we do nothing. We insert a Spacer between each progress bar. Result : Animation and pause \u00b6 We will need a LaunchedEffect : @Preview ( widthDp = 600 ) @Composable fun InstagramSlicedProgressBar ( steps : Int = 3 , currentStep : Int = 2 , paused : Boolean = false , onFinished : () -> Unit = {} ) { val percent = remember { Animatable ( 0f ) } // (1) LaunchedEffect ( paused ) { // (2) if ( paused ) percent . stop () else { percent . animateTo ( targetValue = 1f , animationSpec = tween ( durationMillis = ( 5000 * ( 1f - percent . value )). toInt (), // (3) easing = LinearEasing ) ) onFinished () // (4) } } Row (...) { for (...) { Row (...) { Box ( modifier = Modifier ... . fillMaxHeight (). let { when ( index ) { currentStep -> it . fillMaxWidth ( percent . value ) // (5) ... } }, ) {} } ... } } } Creates an animated value that the composable will remember across recompositions. Every time paused changes, launch the effect in a coroutine. Animate from the current value to 100% with the following spec. It should take 5 seconds to go from 0 to 100% Calls the onFinished callback once animation is done. Use our animated value current value to fill current step. Tadaaa \ud83c\udf89 We are done with our progress bar !","title":"Create an animated Instagram-like progress bar with Jetpack Compose"},{"location":"blog/create-an-animated-instagram-like-progress-bar-with-jetpack-compose/#create-an-animated-instagram-like-progress-bar-with-jetpack-compose","text":"Jetpack Compose is the new and trending way to build Android UI. At BAM , we use it on all new projects. On older projects, we make a plan to refactor good old XML to Composable. This is the first post of a series of How to do this with Jetpack Compose. Note Posts in this series : Create an animated Instagram-like progress bar with Jetpack Compose Detect Instagram-like gestures with Jetpack Compose Info Resources : Link to Github Repo Link to Figma project Let's go !","title":"Create an animated Instagram-like progress bar with Jetpack Compose"},{"location":"blog/create-an-animated-instagram-like-progress-bar-with-jetpack-compose/#recreating-instagrams-stories-progress-bar","text":"Do you know instagram stories ? They are a slideshow of full screen mobile pictures. Here is an example : We will try to recode the progress bar like this : Specs are : we are given a number of steps (number); we are given the current step index (number); we are given whether to pause the progression or not (boolean); we would like to be able to do something when we reach the end of a step (a callback);","title":"Recreating Instagram's stories progress bar"},{"location":"blog/create-an-animated-instagram-like-progress-bar-with-jetpack-compose/#the-layout-of-one-progress-bar","text":"We will use a Row with a background for the progress bar background. And a Box for the progress bar foreground. @Preview ( widthDp = 200 ) @Composable fun ProgressBarPreview () { Row ( modifier = Modifier . height ( 4. dp ) . clip ( RoundedCornerShape ( 50 , 50 , 50 , 50 )) // (1) . background ( Color . White . copy ( alpha = 0.4f )) // (2) ) { Box ( modifier = Modifier . background ( Color . White ) . fillMaxHeight () . fillMaxWidth ( 0.5f ), // (3) ) {} } } Creates rounded corner. Order of Modifier is important. Here, clip is applied on top of background . Adds the white translucent background. Fill a percentage of the width. Result :","title":"The layout of one progress bar"},{"location":"blog/create-an-animated-instagram-like-progress-bar-with-jetpack-compose/#the-layout-of-multiple-progress-bar","text":"We need to iterate over an index. @Preview ( widthDp = 600 ) @Composable fun InstagramSlicedProgressBar ( steps : Int = 3 , currentStep : Int = 2 ) { Row ( verticalAlignment = Alignment . CenterVertically , modifier = Modifier . height ( 48. dp ) . padding ( 24. dp , 0. dp ), ) { for ( index in 1. . steps ) { // (1) // We use our previous code : Row ( ... ) { Box ( modifier = Modifier ... . fillMaxHeight (). let { // Here we check if we need to fill the progress bar of not : when ( index ) { // (2) currentStep -> it . fillMaxWidth (. 5f ) in 0. . currentStep -> it . fillMaxWidth ( 1f ) else -> it } }, ) {} } if ( index != steps ) { Spacer ( modifier = Modifier . width ( 4. dp )) // (3) } } } } We iterate over a range from 1 to the given steps number. Before current step, we fill the progress bar; at the current step, we fill a fraction; after, we do nothing. We insert a Spacer between each progress bar. Result :","title":"The layout of multiple progress bar"},{"location":"blog/create-an-animated-instagram-like-progress-bar-with-jetpack-compose/#animation-and-pause","text":"We will need a LaunchedEffect : @Preview ( widthDp = 600 ) @Composable fun InstagramSlicedProgressBar ( steps : Int = 3 , currentStep : Int = 2 , paused : Boolean = false , onFinished : () -> Unit = {} ) { val percent = remember { Animatable ( 0f ) } // (1) LaunchedEffect ( paused ) { // (2) if ( paused ) percent . stop () else { percent . animateTo ( targetValue = 1f , animationSpec = tween ( durationMillis = ( 5000 * ( 1f - percent . value )). toInt (), // (3) easing = LinearEasing ) ) onFinished () // (4) } } Row (...) { for (...) { Row (...) { Box ( modifier = Modifier ... . fillMaxHeight (). let { when ( index ) { currentStep -> it . fillMaxWidth ( percent . value ) // (5) ... } }, ) {} } ... } } } Creates an animated value that the composable will remember across recompositions. Every time paused changes, launch the effect in a coroutine. Animate from the current value to 100% with the following spec. It should take 5 seconds to go from 0 to 100% Calls the onFinished callback once animation is done. Use our animated value current value to fill current step. Tadaaa \ud83c\udf89 We are done with our progress bar !","title":"Animation and pause"},{"location":"blog/detect-instagram-like-gestures-with-jetpack-compose/","text":"Detect Instagram-like gestures with Jetpack Compose \u00b6 This is the second article of a series about Jetpack Compose. Note Posts in this series : Create an animated Instagram-like progress bar with Jetpack Compose Detect Instagram-like gestures with Jetpack Compose Info Resources : Link to Github Repo Link to Figma project What we'll try to achieve \u00b6 On press on the 1 st left quarter of the screen : go to previous screen. On press on the right 3 quarters of the screen : go to next screen. On press-and-hold anywhere : pause the progress bar. On progress bar finished : go to next screen. Recreating Instagram's stories screen \u00b6 Let's warm up by using our progress bar in a typical Instagram's like screen. @Composable fun InstagramScreen () { // We will hardcode those parameter for now. val steps = 5 ; val currentStep = 2 ; val isPressed = remember { mutableStateOf ( false ) } val goToPreviousScreen = {} val goToNextScreen = {} Column ( horizontalAlignment = Alignment . CenterHorizontally , modifier = Modifier . background ( Brush . linearGradient ( // (1) colors = listOf ( GreenLemon , GreenLeaves , BlueSea ), // (2) start = Offset . Zero , end = Offset . Infinite ) ) ) { InstagramSlicedProgressBar ( steps , currentStep , isPressed . value , goToNextScreen ) Column ( horizontalAlignment = Alignment . CenterHorizontally , verticalArrangement = Arrangement . Center , modifier = Modifier . weight ( 1f ) ) { Text ( text = \"Hello world !\" , style = Typography . h1 , color = Color . White ) Spacer ( modifier = Modifier . height ( 8. dp )) Text ( text = \"Tap or wait to go to the next screen\" , style = Typography . body1 , color = Color . White ) Spacer ( modifier = Modifier . height ( 8. dp )) Text ( text = \"\ud83d\udc49\" , style = Typography . body1 , color = Color . White ) } } } This is the way of creating a linear gradient ! Very useful. Use a list of colours that you like. Mine is : val GreenLemon = Color ( 0 xFFA9F24D ) val GreenLeaves = Color ( 0 xFF00C88C ) val BlueSea = Color ( 0 xFF4895AD ) val Purple = Color ( 0 xFF9248AD ) val RedRaspberry = Color ( 0 xFFE2264C ) Adding gestures \u00b6 Adding gestures to this screen is not very complicated. Jetpack Compose pointerInput modifier is very handful in this situation : @Composable fun InstagramScreen () { // We will hardcode those parameter for now. val steps = 5 ; val currentStep = 2 ; val isPressed = remember { mutableStateOf ( false ) } val goToPreviousScreen = {} val goToNextScreen = {} Column ( horizontalAlignment = Alignment . CenterHorizontally , modifier = Modifier . background ( ... ). pointerInput ( Unit ) { // (1) val maxWidth = this . size . width // (2) detectTapGestures ( onPress = { // (3) val pressStartTime = System . currentTimeMillis () isPressed . value = true this . tryAwaitRelease () // (4) val pressEndTime = System . currentTimeMillis () val totalPressTime = pressEndTime - pressStartTime // (5) if ( totalPressTime < 200 ) { val isTapOnRightTwoTiers = ( it . x > ( maxWidth / 4 )) // (6) if ( isTapOnRightTwoTiers ) { goToNextScreen () } else { goToPreviousScreen () } } isPressed . value = false }, ) } ) { ... } } pointerInput installs a gesture detector. It is attached to some key. If the key change on recomposition, the previous gesture detector is detached and a new one is created. Here we use Unit because we want to install a permanent gesture detector. We can retrieve the Composable's width inside a PointerInputScope ! Wow ! detectTapGestures 's onPress attribute is what we need to detect custom on-press behaviours. It expects a suspend function and provide in its scope a suspendable awaitRelease and tryAwaitRelease functions. Those functions pause the coroutine execution until the user releases its gesture ! We wait for the user to release its gesture. Setting up the navigation \u00b6 We can easily set up a navigation with the androidx.navigation:navigation-compose package. implementation ( \"androidx.navigation:navigation-compose:2.4.0-alpha03\" ) Here is our entry point : @Composable fun Navigation () { val navController = rememberNavController () NavHost ( navController = navController , startDestination = \"instagram/{steps}/{currentStep}\" ) { // (1) composable ( // (2) \"instagram/{steps}/{currentStep}\" , arguments = listOf ( navArgument ( \"steps\" ) { type = NavType . IntType ; defaultValue = 8 }, // (3) navArgument ( \"currentStep\" ) { type = NavType . IntType ; defaultValue = 1 }, // (4) ) ) { backStackEntry -> // (5) InstagramScreen ( navController , backStackEntry . arguments !! . getInt ( \"steps\" ), backStackEntry . arguments !! . getInt ( \"currentStep\" ), ) } } } Here we declare our router. Its start destination is instagram/{steps}/{currentStep} . We declare a route. There are some navigation params : steps and currentStep . steps is an Int ; we can use a default value. currentStep is an Int ; we can use a default value. We pass down our navigation params thanks to backStackEntry argument. Remember our hardcoded values ? Let's change those : @Composable fun InstagramScreen ( navController : NavController , steps : Int , currentStep : Int ) { val goToNextScreen = { if ( currentStep + 1 <= steps ) navController . navigate ( \"instagram/ $ steps / ${ currentStep + 1 } \" ) } val goToPreviousScreen = { if ( currentStep - 1 > 0 ) navController . navigate ( \"instagram/ $ steps / ${ currentStep - 1 } \" ) } ... } Here you go ! The final result is here :","title":"Detect Instagram-like gestures with Jetpack Compose"},{"location":"blog/detect-instagram-like-gestures-with-jetpack-compose/#detect-instagram-like-gestures-with-jetpack-compose","text":"This is the second article of a series about Jetpack Compose. Note Posts in this series : Create an animated Instagram-like progress bar with Jetpack Compose Detect Instagram-like gestures with Jetpack Compose Info Resources : Link to Github Repo Link to Figma project","title":"Detect Instagram-like gestures with Jetpack Compose"},{"location":"blog/detect-instagram-like-gestures-with-jetpack-compose/#what-well-try-to-achieve","text":"On press on the 1 st left quarter of the screen : go to previous screen. On press on the right 3 quarters of the screen : go to next screen. On press-and-hold anywhere : pause the progress bar. On progress bar finished : go to next screen.","title":"What we'll try to achieve"},{"location":"blog/detect-instagram-like-gestures-with-jetpack-compose/#recreating-instagrams-stories-screen","text":"Let's warm up by using our progress bar in a typical Instagram's like screen. @Composable fun InstagramScreen () { // We will hardcode those parameter for now. val steps = 5 ; val currentStep = 2 ; val isPressed = remember { mutableStateOf ( false ) } val goToPreviousScreen = {} val goToNextScreen = {} Column ( horizontalAlignment = Alignment . CenterHorizontally , modifier = Modifier . background ( Brush . linearGradient ( // (1) colors = listOf ( GreenLemon , GreenLeaves , BlueSea ), // (2) start = Offset . Zero , end = Offset . Infinite ) ) ) { InstagramSlicedProgressBar ( steps , currentStep , isPressed . value , goToNextScreen ) Column ( horizontalAlignment = Alignment . CenterHorizontally , verticalArrangement = Arrangement . Center , modifier = Modifier . weight ( 1f ) ) { Text ( text = \"Hello world !\" , style = Typography . h1 , color = Color . White ) Spacer ( modifier = Modifier . height ( 8. dp )) Text ( text = \"Tap or wait to go to the next screen\" , style = Typography . body1 , color = Color . White ) Spacer ( modifier = Modifier . height ( 8. dp )) Text ( text = \"\ud83d\udc49\" , style = Typography . body1 , color = Color . White ) } } } This is the way of creating a linear gradient ! Very useful. Use a list of colours that you like. Mine is : val GreenLemon = Color ( 0 xFFA9F24D ) val GreenLeaves = Color ( 0 xFF00C88C ) val BlueSea = Color ( 0 xFF4895AD ) val Purple = Color ( 0 xFF9248AD ) val RedRaspberry = Color ( 0 xFFE2264C )","title":"Recreating Instagram's stories screen"},{"location":"blog/detect-instagram-like-gestures-with-jetpack-compose/#adding-gestures","text":"Adding gestures to this screen is not very complicated. Jetpack Compose pointerInput modifier is very handful in this situation : @Composable fun InstagramScreen () { // We will hardcode those parameter for now. val steps = 5 ; val currentStep = 2 ; val isPressed = remember { mutableStateOf ( false ) } val goToPreviousScreen = {} val goToNextScreen = {} Column ( horizontalAlignment = Alignment . CenterHorizontally , modifier = Modifier . background ( ... ). pointerInput ( Unit ) { // (1) val maxWidth = this . size . width // (2) detectTapGestures ( onPress = { // (3) val pressStartTime = System . currentTimeMillis () isPressed . value = true this . tryAwaitRelease () // (4) val pressEndTime = System . currentTimeMillis () val totalPressTime = pressEndTime - pressStartTime // (5) if ( totalPressTime < 200 ) { val isTapOnRightTwoTiers = ( it . x > ( maxWidth / 4 )) // (6) if ( isTapOnRightTwoTiers ) { goToNextScreen () } else { goToPreviousScreen () } } isPressed . value = false }, ) } ) { ... } } pointerInput installs a gesture detector. It is attached to some key. If the key change on recomposition, the previous gesture detector is detached and a new one is created. Here we use Unit because we want to install a permanent gesture detector. We can retrieve the Composable's width inside a PointerInputScope ! Wow ! detectTapGestures 's onPress attribute is what we need to detect custom on-press behaviours. It expects a suspend function and provide in its scope a suspendable awaitRelease and tryAwaitRelease functions. Those functions pause the coroutine execution until the user releases its gesture ! We wait for the user to release its gesture.","title":"Adding gestures"},{"location":"blog/detect-instagram-like-gestures-with-jetpack-compose/#setting-up-the-navigation","text":"We can easily set up a navigation with the androidx.navigation:navigation-compose package. implementation ( \"androidx.navigation:navigation-compose:2.4.0-alpha03\" ) Here is our entry point : @Composable fun Navigation () { val navController = rememberNavController () NavHost ( navController = navController , startDestination = \"instagram/{steps}/{currentStep}\" ) { // (1) composable ( // (2) \"instagram/{steps}/{currentStep}\" , arguments = listOf ( navArgument ( \"steps\" ) { type = NavType . IntType ; defaultValue = 8 }, // (3) navArgument ( \"currentStep\" ) { type = NavType . IntType ; defaultValue = 1 }, // (4) ) ) { backStackEntry -> // (5) InstagramScreen ( navController , backStackEntry . arguments !! . getInt ( \"steps\" ), backStackEntry . arguments !! . getInt ( \"currentStep\" ), ) } } } Here we declare our router. Its start destination is instagram/{steps}/{currentStep} . We declare a route. There are some navigation params : steps and currentStep . steps is an Int ; we can use a default value. currentStep is an Int ; we can use a default value. We pass down our navigation params thanks to backStackEntry argument. Remember our hardcoded values ? Let's change those : @Composable fun InstagramScreen ( navController : NavController , steps : Int , currentStep : Int ) { val goToNextScreen = { if ( currentStep + 1 <= steps ) navController . navigate ( \"instagram/ $ steps / ${ currentStep + 1 } \" ) } val goToPreviousScreen = { if ( currentStep - 1 > 0 ) navController . navigate ( \"instagram/ $ steps / ${ currentStep - 1 } \" ) } ... } Here you go ! The final result is here :","title":"Setting up the navigation"},{"location":"kotlin/","text":"Kotlin \u00b6 Things to try out \u00b6 refreshVersions","title":"Kotlin"},{"location":"kotlin/#kotlin","text":"","title":"Kotlin"},{"location":"kotlin/#things-to-try-out","text":"refreshVersions","title":"Things to try out"},{"location":"kotlin/android/architecture/","text":"Architecture \u00b6 @startuml !include <C4/C4_Container> Person(user, \"User\") System_Boundary(c1, \"Android App\") { Container(app, \"Application\", \"Android Module\", \"Loads application dependency graph\") Container(navigation, \"Navigation\", \"Android Module\", \"Declares navigation state machine\") Container(feature_1, \"Feature 1\", \"Android Module\", \"Shows some feature screens\") Container(feature_2, \"Feature 2\", \"Android Module\", \"Shows some feature screens\") Container(lib_1, \"Lib 1\", \"Android Module\", \"Manages business rules and data for some bounded context\") Container(lib_2, \"Lib 2\", \"Android Module\", \"Manages business rules and data for some bounded context\") Container(core, \"Core Lib\", \"Android Module\", \"Manages rules and data for some mobile-standard bounded context. Unlike business libs, they are not related to the business. Thus, they could be shared and used by any app. They are candidates for open source code. E.g.: logging, push notification\") } Rel(user, app, \"Uses\") Rel(app, navigation, \"Launches\") Rel(navigation, feature_1, \"Implements routing for\") Rel(navigation, feature_2, \"Implements routing for\") Rel(feature_1, lib_1, \"Uses\") Rel(feature_1, lib_2, \"Uses\") Rel(feature_2, lib_2, \"Uses\") Rel(lib_2, core, \"Uses\") @enduml","title":"Architecture"},{"location":"kotlin/android/architecture/#architecture","text":"@startuml !include <C4/C4_Container> Person(user, \"User\") System_Boundary(c1, \"Android App\") { Container(app, \"Application\", \"Android Module\", \"Loads application dependency graph\") Container(navigation, \"Navigation\", \"Android Module\", \"Declares navigation state machine\") Container(feature_1, \"Feature 1\", \"Android Module\", \"Shows some feature screens\") Container(feature_2, \"Feature 2\", \"Android Module\", \"Shows some feature screens\") Container(lib_1, \"Lib 1\", \"Android Module\", \"Manages business rules and data for some bounded context\") Container(lib_2, \"Lib 2\", \"Android Module\", \"Manages business rules and data for some bounded context\") Container(core, \"Core Lib\", \"Android Module\", \"Manages rules and data for some mobile-standard bounded context. Unlike business libs, they are not related to the business. Thus, they could be shared and used by any app. They are candidates for open source code. E.g.: logging, push notification\") } Rel(user, app, \"Uses\") Rel(app, navigation, \"Launches\") Rel(navigation, feature_1, \"Implements routing for\") Rel(navigation, feature_2, \"Implements routing for\") Rel(feature_1, lib_1, \"Uses\") Rel(feature_1, lib_2, \"Uses\") Rel(feature_2, lib_2, \"Uses\") Rel(lib_2, core, \"Uses\") @enduml","title":"Architecture"},{"location":"kotlin/android/feature/","text":"Feature \u00b6 @startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(navigation, \"Navigation\", \"Android Module\") Component_Ext(lib, \"Lib\", \"Android Module\") System_Boundary(c2, \"Feature\") { Component(module, \"Module\", \"Kotlin Object\", \"Declares dependency injection container for the current feature.\") Component(router, \"Router\", \"Kotlin Interface\", \"Declares feature navigation's intents.\") System_Boundary(sreens, \"Screens\") { Component(fragment, \"Fragment\", \"Android Fragment\", \"Decalares the UI of one screen.\") Component(viewmodel, \"View Model\", \"Android View Model\", \"Decalares the view model of one screen.\") } } Rel(app, module, \"Loads\") Rel(navigation, router, \"Loads\") Rel(router, fragment, \"Refers to\") Rel(fragment, viewmodel, \"Uses\") Rel(viewmodel, router, \"Sends navigation actions\") Rel(viewmodel, lib, \"Uses\") @enduml","title":"Feature"},{"location":"kotlin/android/feature/#feature","text":"@startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(navigation, \"Navigation\", \"Android Module\") Component_Ext(lib, \"Lib\", \"Android Module\") System_Boundary(c2, \"Feature\") { Component(module, \"Module\", \"Kotlin Object\", \"Declares dependency injection container for the current feature.\") Component(router, \"Router\", \"Kotlin Interface\", \"Declares feature navigation's intents.\") System_Boundary(sreens, \"Screens\") { Component(fragment, \"Fragment\", \"Android Fragment\", \"Decalares the UI of one screen.\") Component(viewmodel, \"View Model\", \"Android View Model\", \"Decalares the view model of one screen.\") } } Rel(app, module, \"Loads\") Rel(navigation, router, \"Loads\") Rel(router, fragment, \"Refers to\") Rel(fragment, viewmodel, \"Uses\") Rel(viewmodel, router, \"Sends navigation actions\") Rel(viewmodel, lib, \"Uses\") @enduml","title":"Feature"},{"location":"kotlin/android/lib/","text":"Lib \u00b6 @startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(star, \"*\", \"Android Module\") System_Boundary(c2, \"Lib\") { Component(module, \"Module\", \"Kotlin Object\", \"Declares dependency injection container for the current lib.\") Component(presenter, \"Presenter\", \"Kotlin singleton class\", \"Declares the module entry points.\") Component(usecase, \"Use Cases\", \"Kotlin factory class\", \"Declares one use case.\") Component(repo_api, \"Repo and API\", \"Room or Retrofit instances\", \"Declares routes and storage API.\") Component(model, \"Models\", \"Kotlin interface\", \"Declares one model.\") } Rel(app, module, \"Loads\") Rel(star, presenter, \"Uses\") Rel(presenter, usecase, \"Executes\") Rel(usecase, repo_api, \"Uses\") Rel(repo_api, model, \"Loads\") @enduml","title":"Lib"},{"location":"kotlin/android/lib/#lib","text":"@startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(star, \"*\", \"Android Module\") System_Boundary(c2, \"Lib\") { Component(module, \"Module\", \"Kotlin Object\", \"Declares dependency injection container for the current lib.\") Component(presenter, \"Presenter\", \"Kotlin singleton class\", \"Declares the module entry points.\") Component(usecase, \"Use Cases\", \"Kotlin factory class\", \"Declares one use case.\") Component(repo_api, \"Repo and API\", \"Room or Retrofit instances\", \"Declares routes and storage API.\") Component(model, \"Models\", \"Kotlin interface\", \"Declares one model.\") } Rel(app, module, \"Loads\") Rel(star, presenter, \"Uses\") Rel(presenter, usecase, \"Executes\") Rel(usecase, repo_api, \"Uses\") Rel(repo_api, model, \"Loads\") @enduml","title":"Lib"},{"location":"kotlin/android/navigation/","text":"Navigation \u00b6 @startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(feature, \"Feature\", \"Android Module\") System_Boundary(c2, \"Lib\") { Component(module, \"Module\", \"Kotlin Object\", \"Declares dependency injection container for the navigation.\") Component(navigator, \"Navigator\", \"Kotlin Class\", \"Declares the navigation's transition executor.\") Component(main_router, \"Main Router\", \"Finite State Machine\", \"Declares the navigation's main state machine.\") Component(router, \"Router\", \"Finite State Machine\", \"Declares one feature's navigation's state machine by implementing its router.\") } Rel(app, module, \"Loads\") Rel(navigator, main_router, \"Uses\") Rel(main_router, router, \"Uses\") Rel(router, feature, \"Implements router of\") @enduml","title":"Navigation"},{"location":"kotlin/android/navigation/#navigation","text":"@startuml !include <C4/C4_Component> Component_Ext(app, \"Application\", \"Android Module\") Component_Ext(feature, \"Feature\", \"Android Module\") System_Boundary(c2, \"Lib\") { Component(module, \"Module\", \"Kotlin Object\", \"Declares dependency injection container for the navigation.\") Component(navigator, \"Navigator\", \"Kotlin Class\", \"Declares the navigation's transition executor.\") Component(main_router, \"Main Router\", \"Finite State Machine\", \"Declares the navigation's main state machine.\") Component(router, \"Router\", \"Finite State Machine\", \"Declares one feature's navigation's state machine by implementing its router.\") } Rel(app, module, \"Loads\") Rel(navigator, main_router, \"Uses\") Rel(main_router, router, \"Uses\") Rel(router, feature, \"Implements router of\") @enduml","title":"Navigation"},{"location":"kotlin/android/debug/adb/","text":"Android Debug Bridge \u00b6 How to known which SDKs an app uses \u00b6 Opening an apk reveals a LOT about which SDK some Android app use Visage de robot I was curious about what other use in their app (Jetpack Compose ? React Native ? Flutter ? Native libs ?). Want to try out ? Take your Android phone (or emulator), download an app \u2b07\ufe0f You need to get the package name of the app. Two ways of doing this : Open your desktop's browser, check the app's Play Store url, it's there : Or open the app and use this command : adb shell dumpsys activity activities . In the logs, you should see which activity is on top. Once you have the package name, find the apk location with this command : adb shell pm path the.package.name.you.found.previously . It returns the location of all apk and the base apk location. Pull it with adb pull the/location/found/previously Open it in Android Studio. Open the classes.dex files and tadaaa Bombe de table You recognize some sdk/lib package names.","title":"Android Debug Bridge"},{"location":"kotlin/android/debug/adb/#android-debug-bridge","text":"","title":"Android Debug Bridge"},{"location":"kotlin/android/debug/adb/#how-to-known-which-sdks-an-app-uses","text":"Opening an apk reveals a LOT about which SDK some Android app use Visage de robot I was curious about what other use in their app (Jetpack Compose ? React Native ? Flutter ? Native libs ?). Want to try out ? Take your Android phone (or emulator), download an app \u2b07\ufe0f You need to get the package name of the app. Two ways of doing this : Open your desktop's browser, check the app's Play Store url, it's there : Or open the app and use this command : adb shell dumpsys activity activities . In the logs, you should see which activity is on top. Once you have the package name, find the apk location with this command : adb shell pm path the.package.name.you.found.previously . It returns the location of all apk and the base apk location. Pull it with adb pull the/location/found/previously Open it in Android Studio. Open the classes.dex files and tadaaa Bombe de table You recognize some sdk/lib package names.","title":"How to known which SDKs an app uses"},{"location":"kotlin/android/infra/android-studio/","text":"Android Studio \u00b6 Troubleshooting \u00b6 \"No tasks available\" \u00b6 It is an issue with the .idea folder. You can try to remove it and restart Android Studio.","title":"Android Studio"},{"location":"kotlin/android/infra/android-studio/#android-studio","text":"","title":"Android Studio"},{"location":"kotlin/android/infra/android-studio/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"kotlin/android/infra/android-studio/#no-tasks-available","text":"It is an issue with the .idea folder. You can try to remove it and restart Android Studio.","title":"\"No tasks available\""},{"location":"kotlin/android/infra/room/","text":"Room \u00b6 Why \u00b6 Have the DB request working properly (no thread exception, etc.) Prerequisites \u00b6 If it is the first database of the module, read the standard \ud83d\udea7 Control points \u00b6 The DB request must work on its own (no API call or anything else) Key steps \u00b6 In core/database, create the entities, DAO interface, and room DAO interface MyDao { // We use single because it returns only one value fun upsert ( element : MyElementEntity ): Single < Unit > // We use flowable because it watches changes and the DB and send new values // It can be converted to Observable // http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html fun getAll (): Flowable < List < MyElementEntity >> } interface RoomMyDao : MyDao { @Insert ( onConflict = OnConflictStrategy . REPLACE ) override fun upsert ( element : MyElementEntity ): Single < Unit > @Query ( \"SELECT * FROM my_element\" ) override fun getAll (): Flowable < List < MyElementEntity >> } @Entity ( tableName = \"my_element\" ) data class MyElementEntity { @PrimaryKey val id : String = UUID . randomUUID (). toString (), @ColumnInfo ( name = \"my_value\" ) val myValue : String , } Register in Room the new entity and DAO (increase version) @Database ( entities = [ A :: class , B :: class , C :: class , MyElementEntity :: class // New ] , version = 6 // New ) @TypeConverters ( Converters :: class ) abstract class MyDatabase : RoomDatabase () { abstract fun aDao (): RoomADao abstract fun bDao (): RoomBDao abstract fun cDao (): RoomCDao abstract fun myDao (): RoomMyDao // New } Register in Koin the new DAO object CoreDatabaseModule { val module = module { single { MyStorageService . db . aDao () } binds arrayOf ( ADao :: class ) single { MyStorageService . db . bDao () } binds arrayOf ( BDao :: class ) single { MyStorageService . db . cDao () } binds arrayOf ( CDao :: class ) single { MyStorageService . db . myDao () } binds arrayOf ( MyDao :: class ) // New } } Warning For non-one-to-one relations between tables, check the room documentation In the lib, create a folder \"repository\", here you should have Adapters between domain and DB (these are different types) fun MyElement . toEntity (): MyElementEntity { // Implementation here } fun MyElementEntity . toDomain (): MyElement { // Implementation here } Calls to the DB class MyRepository ( private val myDao : MyDao ) { fun upsertElement ( element : MyElement ): Single < Unit > { return myDao . upsert ( element . toEntity ()) // We can't do db operations on main thread . subscribeOn ( Schedulers . io ()) } fun getAll (): Observable < List < MyElement >> { return myDao . getAll () // Get all is an flowable but we are used to observable in the code . toObservable () . map { elements -> elements . map { it . toDomain () } } // We can't do db operations on main thread . subscribeOn ( Schedulers . io ()) } } You can now use the calls from \"repository\" inside your cqrs Mistakes to avoid \u00b6 Forget to do a migration when affecting an existing table Forget to register in room and in koin Forget to be on an io thread","title":"Room"},{"location":"kotlin/android/infra/room/#room","text":"","title":"Room"},{"location":"kotlin/android/infra/room/#why","text":"Have the DB request working properly (no thread exception, etc.)","title":"Why"},{"location":"kotlin/android/infra/room/#prerequisites","text":"If it is the first database of the module, read the standard \ud83d\udea7","title":"Prerequisites"},{"location":"kotlin/android/infra/room/#control-points","text":"The DB request must work on its own (no API call or anything else)","title":"Control points"},{"location":"kotlin/android/infra/room/#key-steps","text":"In core/database, create the entities, DAO interface, and room DAO interface MyDao { // We use single because it returns only one value fun upsert ( element : MyElementEntity ): Single < Unit > // We use flowable because it watches changes and the DB and send new values // It can be converted to Observable // http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html fun getAll (): Flowable < List < MyElementEntity >> } interface RoomMyDao : MyDao { @Insert ( onConflict = OnConflictStrategy . REPLACE ) override fun upsert ( element : MyElementEntity ): Single < Unit > @Query ( \"SELECT * FROM my_element\" ) override fun getAll (): Flowable < List < MyElementEntity >> } @Entity ( tableName = \"my_element\" ) data class MyElementEntity { @PrimaryKey val id : String = UUID . randomUUID (). toString (), @ColumnInfo ( name = \"my_value\" ) val myValue : String , } Register in Room the new entity and DAO (increase version) @Database ( entities = [ A :: class , B :: class , C :: class , MyElementEntity :: class // New ] , version = 6 // New ) @TypeConverters ( Converters :: class ) abstract class MyDatabase : RoomDatabase () { abstract fun aDao (): RoomADao abstract fun bDao (): RoomBDao abstract fun cDao (): RoomCDao abstract fun myDao (): RoomMyDao // New } Register in Koin the new DAO object CoreDatabaseModule { val module = module { single { MyStorageService . db . aDao () } binds arrayOf ( ADao :: class ) single { MyStorageService . db . bDao () } binds arrayOf ( BDao :: class ) single { MyStorageService . db . cDao () } binds arrayOf ( CDao :: class ) single { MyStorageService . db . myDao () } binds arrayOf ( MyDao :: class ) // New } } Warning For non-one-to-one relations between tables, check the room documentation In the lib, create a folder \"repository\", here you should have Adapters between domain and DB (these are different types) fun MyElement . toEntity (): MyElementEntity { // Implementation here } fun MyElementEntity . toDomain (): MyElement { // Implementation here } Calls to the DB class MyRepository ( private val myDao : MyDao ) { fun upsertElement ( element : MyElement ): Single < Unit > { return myDao . upsert ( element . toEntity ()) // We can't do db operations on main thread . subscribeOn ( Schedulers . io ()) } fun getAll (): Observable < List < MyElement >> { return myDao . getAll () // Get all is an flowable but we are used to observable in the code . toObservable () . map { elements -> elements . map { it . toDomain () } } // We can't do db operations on main thread . subscribeOn ( Schedulers . io ()) } } You can now use the calls from \"repository\" inside your cqrs","title":"Key steps"},{"location":"kotlin/android/infra/room/#mistakes-to-avoid","text":"Forget to do a migration when affecting an existing table Forget to register in room and in koin Forget to be on an io thread","title":"Mistakes to avoid"},{"location":"kotlin/build/gradle/","text":"Gradle \u00b6 How to keep version catalog up-to-date ? \u00b6 Use dependabot . Recommended approach \u00b6 Create a dependencies.gradle file with all versions and package constants. ext { // Version sorted alphabetically versions = [ android_gradle_plugin : '7.0.0-beta03' , firebase_analytics : \"18.0.2\" , flipper : \"0.74.0\" , fresco : \"2.4.0\" , google_gson : \"2.8.6\" //... ] runDependencies = [ androidx_appcompat : \"androidx.appcompat:appcompat:${versions.androidx_appcompat}\" , androidx_biometric : \"androidx.biometric:biometric:${versions.androidx_biometric}\" , androidx_browser : \"androidx.browser:browser:${versions.androidx_browser}\" , androidx_constraintlayout : \"androidx.constraintlayout:constraintlayout:${versions.androidx_constraintlayout}\" , androidx_camera : \"androidx.camera:camera-camera2:${versions.androidx_camera}\" , androidx_camera_lifecycle : \"androidx.camera:camera-lifecycle:${versions.androidx_camera}\" , androidx_camera_view : \"androidx.camera:camera-view:${versions.androidx_camera_view}\" , androidx_core : \"androidx.core:core-ktx:${versions.androidx_core}\" //... ] } Add this file to all projects in the root build.gradle . allprojects { project . apply from: rootProject . file ( \"dependencies.gradle\" ) } Use it in modules build.gradle files. implementation runDependencies . kotlin_std_lib implementation runDependencies . koin_android implementation runDependencies . koin_android_view_model implementation runDependencies . androidx_appcompat implementation runDependencies . androidx_core ... Pros Cons \u2795 one location for all dependencies declaration \u2796 no auto-complete Other approach to try out : refreshVersions \u00b6 refreshVersions Pros Cons \u2795 one location for all dependencies declaration \u2796 no auto-complete \u2795 auto-complete \u2796 automatic pull-requests to setup manually (but doable) \u2795 choose among all available versions Other approach to try out : Centralized dependency versions with Gradle 7.0 \u00b6 See the releases notes . Pros Cons \u2795 one location for all dependencies declaration \u2796 no auto-complete \u2796 toml not supported in Android Studio \u2796 is it supported by Dependabot ? How to speed up Gradle Builds ? \u00b6 Enable build cache \u00b6 Add the following to your gradle properties file gradle.properties . # Cache builds # By default, build cache is not enabled. org.gradle.caching=true # Kapt Worker # Running kapt tasks in parallel (https://kotlinlang.org/docs/kapt.html#running-kapt-tasks-in-parallel-since-1-2-60). kapt.use.worker.api=true # Kapt Compile Avoidance # https://kotlinlang.org/docs/kapt.html#compile-avoidance-for-kapt-since-1-3-20 kapt.include.compile.classpath=false Modularize your project \u00b6 Try out a shared cache with gradle/build-cache-node docker image \u00b6 https://hub.docker.com/r/gradle/build-cache-node/","title":"Gradle"},{"location":"kotlin/build/gradle/#gradle","text":"","title":"Gradle"},{"location":"kotlin/build/gradle/#how-to-keep-version-catalog-up-to-date","text":"Use dependabot .","title":"How to keep version catalog up-to-date ?"},{"location":"kotlin/build/gradle/#recommended-approach","text":"Create a dependencies.gradle file with all versions and package constants. ext { // Version sorted alphabetically versions = [ android_gradle_plugin : '7.0.0-beta03' , firebase_analytics : \"18.0.2\" , flipper : \"0.74.0\" , fresco : \"2.4.0\" , google_gson : \"2.8.6\" //... ] runDependencies = [ androidx_appcompat : \"androidx.appcompat:appcompat:${versions.androidx_appcompat}\" , androidx_biometric : \"androidx.biometric:biometric:${versions.androidx_biometric}\" , androidx_browser : \"androidx.browser:browser:${versions.androidx_browser}\" , androidx_constraintlayout : \"androidx.constraintlayout:constraintlayout:${versions.androidx_constraintlayout}\" , androidx_camera : \"androidx.camera:camera-camera2:${versions.androidx_camera}\" , androidx_camera_lifecycle : \"androidx.camera:camera-lifecycle:${versions.androidx_camera}\" , androidx_camera_view : \"androidx.camera:camera-view:${versions.androidx_camera_view}\" , androidx_core : \"androidx.core:core-ktx:${versions.androidx_core}\" //... ] } Add this file to all projects in the root build.gradle . allprojects { project . apply from: rootProject . file ( \"dependencies.gradle\" ) } Use it in modules build.gradle files. implementation runDependencies . kotlin_std_lib implementation runDependencies . koin_android implementation runDependencies . koin_android_view_model implementation runDependencies . androidx_appcompat implementation runDependencies . androidx_core ... Pros Cons \u2795 one location for all dependencies declaration \u2796 no auto-complete","title":"Recommended approach"},{"location":"kotlin/build/gradle/#other-approach-to-try-out-refreshversions","text":"refreshVersions Pros Cons \u2795 one location for all dependencies declaration \u2796 no auto-complete \u2795 auto-complete \u2796 automatic pull-requests to setup manually (but doable) \u2795 choose among all available versions","title":"Other approach to try out : refreshVersions"},{"location":"kotlin/build/gradle/#other-approach-to-try-out-centralized-dependency-versions-with-gradle-70","text":"See the releases notes . Pros Cons \u2795 one location for all dependencies declaration \u2796 no auto-complete \u2796 toml not supported in Android Studio \u2796 is it supported by Dependabot ?","title":"Other approach to try out : Centralized dependency versions with Gradle 7.0"},{"location":"kotlin/build/gradle/#how-to-speed-up-gradle-builds","text":"","title":"How to speed up Gradle Builds ?"},{"location":"kotlin/build/gradle/#enable-build-cache","text":"Add the following to your gradle properties file gradle.properties . # Cache builds # By default, build cache is not enabled. org.gradle.caching=true # Kapt Worker # Running kapt tasks in parallel (https://kotlinlang.org/docs/kapt.html#running-kapt-tasks-in-parallel-since-1-2-60). kapt.use.worker.api=true # Kapt Compile Avoidance # https://kotlinlang.org/docs/kapt.html#compile-avoidance-for-kapt-since-1-3-20 kapt.include.compile.classpath=false","title":"Enable build cache"},{"location":"kotlin/build/gradle/#modularize-your-project","text":"","title":"Modularize your project"},{"location":"kotlin/build/gradle/#try-out-a-shared-cache-with-gradlebuild-cache-node-docker-image","text":"https://hub.docker.com/r/gradle/build-cache-node/","title":"Try out a shared cache with gradle/build-cache-node docker image"},{"location":"kotlin/build/dependencies/maven_central/","text":"","title":"Maven central"},{"location":"kotlin/infra/libphonenumber/","text":"Libphonenumber \u00b6 https://github.com/google/libphonenumber/blob/master/FALSEHOODS.md Falsehood \u00b6 https://github.com/google/libphonenumber/blob/master/FALSEHOODS.md","title":"Libphonenumber"},{"location":"kotlin/infra/libphonenumber/#libphonenumber","text":"https://github.com/google/libphonenumber/blob/master/FALSEHOODS.md","title":"Libphonenumber"},{"location":"kotlin/infra/libphonenumber/#falsehood","text":"https://github.com/google/libphonenumber/blob/master/FALSEHOODS.md","title":"Falsehood"},{"location":"kotlin/infra/compose/layout/","text":"Layout with Jetpack Compose \u00b6 Column \u00b6 Of course. Row \u00b6 Of course. Box \u00b6 Use box to stack elements in a box. Use it as position: absolute web CSS replacement. For example, when you need to center a title and align a button to the right, use a box.","title":"Layout with Jetpack Compose"},{"location":"kotlin/infra/compose/layout/#layout-with-jetpack-compose","text":"","title":"Layout with Jetpack Compose"},{"location":"kotlin/infra/compose/layout/#column","text":"Of course.","title":"Column"},{"location":"kotlin/infra/compose/layout/#row","text":"Of course.","title":"Row"},{"location":"kotlin/infra/compose/layout/#box","text":"Use box to stack elements in a box. Use it as position: absolute web CSS replacement. For example, when you need to center a title and align a button to the right, use a box.","title":"Box"},{"location":"swift/","text":"Swift \u00b6","title":"Swift"},{"location":"swift/#swift","text":"","title":"Swift"},{"location":"swift/core-image/","text":"","title":"Index"},{"location":"swift/core-image/ci_filter/","text":"CIFilter \u00b6 cifilter.io Barcode and QRCode \u00b6 You can generate a barcode / a QRcode with CI Filter The code below needs to be run in a playground. import UIKit import PlaygroundSupport class MyViewController : UIViewController { override func loadView () { super . loadView () let view = UIView () view . backgroundColor = . white let barcode = generateBarcode ( from : \"Hello world\" ) view . addSubview ( UIImageView ( image : barcode )) self . view = view } func generateBarcode ( from string : String ) -> UIImage ? { let data = string . data ( using : String . Encoding . ascii ) if let filter = CIFilter ( name : \"CICode128BarcodeGenerator\" ) { // (1) filter . setValue ( data , forKey : \"inputMessage\" ) if let output = filter . outputImage { return UIImage ( ciImage : output ) // (2) } } return nil } } PlaygroundPage . current . liveView = MyViewController () // (3) See cifilter.io for other code generator Create image from filter output Render the view controller in the playground Play a transparent video \u00b6 Video format with transparant background are not supported on iOS. First, generate your video in the mp4 format with the RGB channel on the left and the alpha channel (converted in grayscale) on the right. See Quentin Fasquel's artical to see how implement the CI Filter. The key code: extension MyView { private func setupVideoView () { let videoUrl = bundle . url ( forResource : videoName , withExtension : \"mp4\" ) ! let playerItem = AVPlayerItem ( url : videoUrl ) let player = AVQueuePlayer ( items : [ playerItem ]) playerLooper = AVPlayerLooper ( player : player , templateItem : playerItem ) // (1) let playerLayer = AVPlayerLayer ( player : player ) layer . addSublayer ( playerLayer ) playerLayer . bounds = bounds playerLayer . position = position playerLayer . pixelBufferAttributes = [ kCVPixelBufferPixelFormatTypeKey as String : kCVPixelFormatType_32BGRA ] // (2) playerItem . videoComposition = createVideoComposition ( for : playerItem ) player . seek ( to : . zero ) player . play () } private func createVideoComposition ( for playerItem : AVPlayerItem ) -> AVVideoComposition { let videoSize = onboardingTheme . videoSize let composition = AVMutableVideoComposition ( asset : playerItem . asset , applyingCIFiltersWithHandler : { request in let sourceRect = CGRect ( origin : . zero , size : videoSize ) let alphaRect = sourceRect . offsetBy ( dx : sourceRect . width , dy : 0 ) // (3) let transform = CGAffineTransform ( translationX : - sourceRect . width , y : 0 ) let filter = AlphaFrameFilter () filter . maskImage = request . sourceImage . cropped ( to : alphaRect ). transformed ( by : transform ) filter . inputImage = request . sourceImage . cropped ( to : sourceRect ) return request . finish ( with : filter . outputImage !, context : nil ) }) composition . renderSize = videoSize return composition } } class AlphaFrameFilter : CIFilter { static var kernel : CIColorKernel ? = { CIColorKernel ( source : \"\"\" kernel vec4 alphaFrame(__sample s, __sample m) { return vec4( s.rgb, m.r ); } \"\"\" ) // (4) }() var inputImage : CIImage ? var maskImage : CIImage ? override var outputImage : CIImage ? { let kernel = AlphaFrameFilter . kernel ! guard let inputImage = inputImage , let maskImage = maskImage else { return nil } let args = [ inputImage as AnyObject , maskImage as AnyObject ] return kernel . apply ( extent : inputImage . extent , arguments : args ) } } playerLopper is the object allowing us to loop the video. It should be declared as a property from the view. Otherwise, it will be garbage collected. Indicate the player that it will recieve an alpha channel We split the image in two: the original image and its mask This code is in OpenGL. It created a 4-channel image from a 3-channel image and the mask","title":"CIFilter"},{"location":"swift/core-image/ci_filter/#cifilter","text":"cifilter.io","title":"CIFilter"},{"location":"swift/core-image/ci_filter/#barcode-and-qrcode","text":"You can generate a barcode / a QRcode with CI Filter The code below needs to be run in a playground. import UIKit import PlaygroundSupport class MyViewController : UIViewController { override func loadView () { super . loadView () let view = UIView () view . backgroundColor = . white let barcode = generateBarcode ( from : \"Hello world\" ) view . addSubview ( UIImageView ( image : barcode )) self . view = view } func generateBarcode ( from string : String ) -> UIImage ? { let data = string . data ( using : String . Encoding . ascii ) if let filter = CIFilter ( name : \"CICode128BarcodeGenerator\" ) { // (1) filter . setValue ( data , forKey : \"inputMessage\" ) if let output = filter . outputImage { return UIImage ( ciImage : output ) // (2) } } return nil } } PlaygroundPage . current . liveView = MyViewController () // (3) See cifilter.io for other code generator Create image from filter output Render the view controller in the playground","title":"Barcode and QRCode"},{"location":"swift/core-image/ci_filter/#play-a-transparent-video","text":"Video format with transparant background are not supported on iOS. First, generate your video in the mp4 format with the RGB channel on the left and the alpha channel (converted in grayscale) on the right. See Quentin Fasquel's artical to see how implement the CI Filter. The key code: extension MyView { private func setupVideoView () { let videoUrl = bundle . url ( forResource : videoName , withExtension : \"mp4\" ) ! let playerItem = AVPlayerItem ( url : videoUrl ) let player = AVQueuePlayer ( items : [ playerItem ]) playerLooper = AVPlayerLooper ( player : player , templateItem : playerItem ) // (1) let playerLayer = AVPlayerLayer ( player : player ) layer . addSublayer ( playerLayer ) playerLayer . bounds = bounds playerLayer . position = position playerLayer . pixelBufferAttributes = [ kCVPixelBufferPixelFormatTypeKey as String : kCVPixelFormatType_32BGRA ] // (2) playerItem . videoComposition = createVideoComposition ( for : playerItem ) player . seek ( to : . zero ) player . play () } private func createVideoComposition ( for playerItem : AVPlayerItem ) -> AVVideoComposition { let videoSize = onboardingTheme . videoSize let composition = AVMutableVideoComposition ( asset : playerItem . asset , applyingCIFiltersWithHandler : { request in let sourceRect = CGRect ( origin : . zero , size : videoSize ) let alphaRect = sourceRect . offsetBy ( dx : sourceRect . width , dy : 0 ) // (3) let transform = CGAffineTransform ( translationX : - sourceRect . width , y : 0 ) let filter = AlphaFrameFilter () filter . maskImage = request . sourceImage . cropped ( to : alphaRect ). transformed ( by : transform ) filter . inputImage = request . sourceImage . cropped ( to : sourceRect ) return request . finish ( with : filter . outputImage !, context : nil ) }) composition . renderSize = videoSize return composition } } class AlphaFrameFilter : CIFilter { static var kernel : CIColorKernel ? = { CIColorKernel ( source : \"\"\" kernel vec4 alphaFrame(__sample s, __sample m) { return vec4( s.rgb, m.r ); } \"\"\" ) // (4) }() var inputImage : CIImage ? var maskImage : CIImage ? override var outputImage : CIImage ? { let kernel = AlphaFrameFilter . kernel ! guard let inputImage = inputImage , let maskImage = maskImage else { return nil } let args = [ inputImage as AnyObject , maskImage as AnyObject ] return kernel . apply ( extent : inputImage . extent , arguments : args ) } } playerLopper is the object allowing us to loop the video. It should be declared as a property from the view. Otherwise, it will be garbage collected. Indicate the player that it will recieve an alpha channel We split the image in two: the original image and its mask This code is in OpenGL. It created a 4-channel image from a 3-channel image and the mask","title":"Play a transparent video"},{"location":"swift/devx/","text":"","title":"Index"},{"location":"swift/devx/debug/","text":"","title":"Index"},{"location":"swift/devx/debug/breakpoints/","text":"Breakpoints \u00b6 With conditions \u00b6 In Xcode, right-click on breakpoints to add conditions. You can even do some actions, like po to print the variable in the console. Disable all breakpoints \u00b6 When running your app, you can deactivate all your breakpoints and conserve their state, enabled or disabled. Just below the code area, select the blue arrow. Enable breakpoint only inside / outside \u00b6 If you program in Swift, you are probably using closures (similar to lambdas in other languages). Sometimes, your line contains both a closure and its surrounding environment. An extreme example can be this func myFunction ( dict : [ String :[ String ]]) { dict . map { ( key , value ) in value . map { string in string . trimmingCharacters ( in : . whitespaces ) } } Here we have 2 closures and a surrounding environment. When building, Xcode expands the breakpoint in 3 sub-breakpoints in the breakpoint navigator. You can now enable or disable the one you want by looking at the closure signature.","title":"Breakpoints"},{"location":"swift/devx/debug/breakpoints/#breakpoints","text":"","title":"Breakpoints"},{"location":"swift/devx/debug/breakpoints/#with-conditions","text":"In Xcode, right-click on breakpoints to add conditions. You can even do some actions, like po to print the variable in the console.","title":"With conditions"},{"location":"swift/devx/debug/breakpoints/#disable-all-breakpoints","text":"When running your app, you can deactivate all your breakpoints and conserve their state, enabled or disabled. Just below the code area, select the blue arrow.","title":"Disable all breakpoints"},{"location":"swift/devx/debug/breakpoints/#enable-breakpoint-only-inside-outside","text":"If you program in Swift, you are probably using closures (similar to lambdas in other languages). Sometimes, your line contains both a closure and its surrounding environment. An extreme example can be this func myFunction ( dict : [ String :[ String ]]) { dict . map { ( key , value ) in value . map { string in string . trimmingCharacters ( in : . whitespaces ) } } Here we have 2 closures and a surrounding environment. When building, Xcode expands the breakpoint in 3 sub-breakpoints in the breakpoint navigator. You can now enable or disable the one you want by looking at the closure signature.","title":"Enable breakpoint only inside / outside"},{"location":"swift/devx/debug/design/","text":"Design \u00b6 View hierarchy \u00b6 When running your app (it can be outside of a breakpoint), on the screen you want to verify, click on the \u201cDebug view hierarchy\u201d, on the bar between your code and the debugging area. You can then see a 3D representation of your view with elements overlapping each other. Geometry details \u00b6 When you select a specific element in Debug View hierarchy, in the inspector panel, you may also find precise information about the geometry.","title":"Design"},{"location":"swift/devx/debug/design/#design","text":"","title":"Design"},{"location":"swift/devx/debug/design/#view-hierarchy","text":"When running your app (it can be outside of a breakpoint), on the screen you want to verify, click on the \u201cDebug view hierarchy\u201d, on the bar between your code and the debugging area. You can then see a 3D representation of your view with elements overlapping each other.","title":"View hierarchy"},{"location":"swift/devx/debug/design/#geometry-details","text":"When you select a specific element in Debug View hierarchy, in the inspector panel, you may also find precise information about the geometry.","title":"Geometry details"},{"location":"swift/devx/debug/memory/","text":"Memory \u00b6 Memory graph \u00b6 In Swift, objects are kept in memory as long as there is one strong reference to them. If you don\u2019t use your object and it is still in memory, you probably forgot one strong reference. To see what keeps an object alive, you can use the memory graph. Press the memory graph icon whenever you want while running the application. The only condition is that your device (or your simulator) must have a recent version of iOS (at least iOS 13.x when writing this article). An arrow means \u201cthis object has a reference to this one\u201d. If the arrow is bold, that means that the reference is a strong one. Backtrace of the object \u00b6 Open your scheme. Select \"Run\" on the left panel, then \"Diagnostics\". You must now select the line \"Malloc Stack Logging\" as shown below. You can then open the inspector panel, go to the memory inspector. It will load a precise backtrace of where your object is kept alive. You can even click on the lines to see the precise piece of code.","title":"Memory"},{"location":"swift/devx/debug/memory/#memory","text":"","title":"Memory"},{"location":"swift/devx/debug/memory/#memory-graph","text":"In Swift, objects are kept in memory as long as there is one strong reference to them. If you don\u2019t use your object and it is still in memory, you probably forgot one strong reference. To see what keeps an object alive, you can use the memory graph. Press the memory graph icon whenever you want while running the application. The only condition is that your device (or your simulator) must have a recent version of iOS (at least iOS 13.x when writing this article). An arrow means \u201cthis object has a reference to this one\u201d. If the arrow is bold, that means that the reference is a strong one.","title":"Memory graph"},{"location":"swift/devx/debug/memory/#backtrace-of-the-object","text":"Open your scheme. Select \"Run\" on the left panel, then \"Diagnostics\". You must now select the line \"Malloc Stack Logging\" as shown below. You can then open the inspector panel, go to the memory inspector. It will load a precise backtrace of where your object is kept alive. You can even click on the lines to see the precise piece of code.","title":"Backtrace of the object"}]}